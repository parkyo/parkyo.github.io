<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://parkyo.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="https://parkyo.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://parkyo.github.io/" rel="alternate" type="text/html" /><updated>2020-08-01T20:05:50+09:00</updated><id>https://parkyo.github.io/</id><title type="html">Younse Park</title><subtitle>Hi, I am a software engineer</subtitle><entry><title type="html">Sliding Window Technique</title><link href="https://parkyo.github.io/categories/sliding-window/" rel="alternate" type="text/html" title="Sliding Window Technique" /><published>2020-08-01T00:00:00+09:00</published><updated>2020-08-01T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/sliding-window</id><content type="html" xml:base="https://parkyo.github.io/categories/sliding-window/">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=MK-NZ4hN7rs&quot;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sliding window technique&lt;/strong&gt; improves the efficiency of iteration from O(n*k) to O(n)&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given an array of integers of size ‘n’.
Our aim is to calculate the maximum sum of ‘k’ consecutive elements in the array.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;brute Force Solution&lt;/strong&gt; to this problem would be the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;int maxSum(int arr[], int n, int k) 
{ 
    &lt;/strong&gt;// Initialize result &lt;strong&gt;
    int max_sum = INT_MIN; 
  &lt;/strong&gt;
    // Consider all blocks starting with i. &lt;strong&gt;
    for (int i = 0; i &amp;lt; n - k + 1; i++) { 
        int current_sum = 0; 
        for (int j = 0; j &amp;lt; k; j++) 
            current_sum = current_sum + arr[i + j]; 
  &lt;/strong&gt;
        // Update result if required. &lt;strong&gt;
        max_sum = max(current_sum, max_sum); 
    } 
  
    return max_sum; 
} &lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Time Complexity : &lt;i&gt;O(n*k)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With &lt;strong&gt;sliding window technique&lt;/strong&gt;, we can have a window of k elements and keep track of the current sum of the k element sand the maximum sum found so far. We can slide this window through the array to find the answer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;strong&gt;int maxSum(int arr[], int n, int k) 
{ 
    &lt;/strong&gt;// n must be greater &lt;strong&gt;
    if (n &amp;lt; k) { 
        cout &amp;lt;&amp;lt; &quot;Invalid&quot;; 
        return -1; 
    } 
  &lt;/strong&gt;
    // Compute sum of first window of size k &lt;strong&gt;
    int max_sum = 0; 
    for (int i = 0; i &amp;lt; k; i++) 
        max_sum += arr[i]; 
  &lt;/strong&gt;
    // Compute sums of remaining windows by 
    // removing first element of previous 
    // window and adding last element of 
    // current window. &lt;strong&gt;
    int window_sum = max_sum; 
    for (int i = k; i &amp;lt; n; i++) { 
        window_sum += arr[i] - arr[i - k]; 
        max_sum = max(max_sum, window_sum); 
    } 
  
    return max_sum; 
} &lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Time Complexity : &lt;i&gt;O(n)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;uses&quot;&gt;Uses&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Sequentially iterate over
    &lt;ul&gt;
      &lt;li&gt;contiguous sequence of elements&lt;/li&gt;
      &lt;li&gt;strings, arrays, linked list&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;To find min, max, longest, shortest, or whether contained
    &lt;ul&gt;
      &lt;li&gt;may need calculation and record some value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;li&gt;Everything grouped &lt;strong&gt;sequentially&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Longest/ smallest/ contains/ max/ min&lt;/strong&gt;&lt;/li&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;Learn about &lt;a href=&quot;/dyanamic-sliding-window/&quot;&gt;Dynamic Version&lt;/a&gt; of Sliding Window Technique&lt;/blockquote&gt;</content><category term="blog" /><category term="algorithm" /><category term="sliding_window" /><summary type="html">reference</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Sliding Window Technique with Dynamic Variant</title><link href="https://parkyo.github.io/categories/dyanamic-sliding-window/" rel="alternate" type="text/html" title="Sliding Window Technique with Dynamic Variant" /><published>2020-08-01T00:00:00+09:00</published><updated>2020-08-01T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/dyanamic-sliding-window</id><content type="html" xml:base="https://parkyo.github.io/categories/dyanamic-sliding-window/">&lt;p&gt;&lt;a href=&quot;/sliding-window/&quot;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;h3 id=&quot;problem-1&quot;&gt;Problem 1&lt;/h3&gt;
&lt;p&gt;Find the &lt;strong&gt;smallest subarray&lt;/strong&gt; with given sum&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;
&lt;p&gt;As you iterate through the array, move the start of the window to the left while the sum of the window elements is still bigger than or equal to the targetSum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;strong&gt;int smallestSubarray(int targetSum, vector&amp;lt;int&amp;gt; arr) 
{ 
    int start = 0;
    int cur_sum = 0;
    int min_size = INT_MAX;
    for (int i = 0; i &amp;lt; arr.size(); ++i){
        cur_sum += arr[i];
        while(cur_sum &amp;gt;= targetSum){
            min_size = min(min_size, i - start + 1);
            cur_sum -= arr[start];
            ++start;
        }
    }
    return min_size;
} &lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Time Complexity : &lt;i&gt;O(n^2)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem-2&quot;&gt;Problem 2&lt;/h3&gt;
&lt;p&gt;Find the &lt;strong&gt;longest substring&lt;/strong&gt; length with K distinct characters&lt;/p&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;
&lt;p&gt;Similar to the solution to the previous problem. 
Keep track of the number of each distinct character in a hashmap and check the size of the hashmap to see if you have violated the required number of characers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;strong&gt;int longestSubstr(int k, string&amp;amp; s){
    int start = 0, max_size = 0;
    unordered_map&amp;lt;char, int&amp;gt; map;
    for (char c : s){
        auto it = map.find(c);
        if(it != map.end()){
            ++(it-&amp;gt;second);
        }else{
            map.insert(pair&amp;lt;char,int&amp;gt;(c, 1));
        }
        while(map.size() &amp;gt; k){
            auto it2 = map.find(s[start]);
            if((it2-&amp;gt;second) == 1){
                map.erase(it2);
            }else{
                --(it2-&amp;gt;second);
            }
            ++start;
        }
        if(max_size &amp;lt; map.size()){
            max_size = map.size();
        }
    }
    return max_size;
}&lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;</content><category term="blog" /><category term="algorithm" /><category term="sliding_window" /><summary type="html">reference</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">What is ‘npm’</title><link href="https://parkyo.github.io/categories/npm/" rel="alternate" type="text/html" title="What is 'npm'" /><published>2020-07-30T00:00:00+09:00</published><updated>2020-07-30T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/npm</id><content type="html" xml:base="https://parkyo.github.io/categories/npm/">&lt;p&gt;&lt;a href=&quot;https://docs.npmjs.com/cli/npm&quot;&gt;doc&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm &amp;lt;command&amp;gt; [args]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;npm&lt;/strong&gt; is Node JavaScript platform package manager. It can publish, discover, install, and develop node programs. It can also install all the dependencies of a project, defined in &lt;strong&gt;package.json&lt;/strong&gt;&lt;/p&gt;</content><category term="blog" /><category term="npm" /><summary type="html">doc</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Leetcode Biweekly Contest 30 - Number of Subarrays with Odd Sums</title><link href="https://parkyo.github.io/categories/numOddSums/" rel="alternate" type="text/html" title="Leetcode Biweekly Contest 30 - Number of Subarrays with Odd Sums" /><published>2020-07-29T00:00:00+09:00</published><updated>2020-07-29T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/numOddSums</id><content type="html" xml:base="https://parkyo.github.io/categories/numOddSums/">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/&quot;&gt;LINK&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;level--medium&quot;&gt;Level : Medium&lt;/h3&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given an array of integers arr. Return the number of sub-arrays with odd sum.&lt;/p&gt;

&lt;p&gt;As the answer may grow large, the answer must be computed modulo 10^9 + 7.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Keep track of the number of subarrays of odd sums and even sums.&lt;/li&gt;
  &lt;li&gt;If the element is odd, swap odd and even and increment odd&lt;/li&gt;
  &lt;li&gt;If the element is even, increment even&lt;/li&gt;
  &lt;li&gt;Add the number for every element to the sum&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;int numOfSubarrays(vector&amp;lt;int&amp;gt;&amp;amp; arr) {
      int odd = 0, even = 0, sum = 0;
      for(auto a : arr){
          if(a % 2 == 1){
              swap(odd, even);
              ++odd;
          }else{
              ++even;
          }
          sum += odd;
      }
      return sum % 10000000007;
  }&lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time copmlexity: &lt;i&gt;O(n)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="blog" /><category term="algorithm" /><category term="leetcode" /><category term="biweekly_contest" /><summary type="html">LINK</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Tips for Solving Coding Problems</title><link href="https://parkyo.github.io/categories/coding-prob-tips/" rel="alternate" type="text/html" title="Tips for Solving Coding Problems" /><published>2020-07-27T00:00:00+09:00</published><updated>2020-07-27T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/coding-prob-tips</id><content type="html" xml:base="https://parkyo.github.io/categories/coding-prob-tips/">&lt;li&gt;When the only solution seems to be a long search, then focus on finding the 'bound' 
&lt;a href=&quot;https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/&quot;&gt;ex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;</content><category term="blog" /><category term="algorithm" /><summary type="html">When the only solution seems to be a long search, then focus on finding the 'bound' 
ex</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Leetcode Bi-Weekly Contest 31 - Good ways to split a string</title><link href="https://parkyo.github.io/categories/leetcode-goodsplit/" rel="alternate" type="text/html" title="Leetcode Bi-Weekly Contest 31 - Good ways to split a string" /><published>2020-07-25T00:00:00+09:00</published><updated>2020-07-25T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/leetcode-goodsplit</id><content type="html" xml:base="https://parkyo.github.io/categories/leetcode-goodsplit/">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-good-ways-to-split-a-string/submissions/&quot;&gt;LINK&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;level--medium&quot;&gt;Level : Medium&lt;/h3&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;You are given a string s, a split is called good if you can split s into 2 non-empty strings p and q where its concatenation is equal to s and the number of distinct letters in p and q are the same.&lt;/p&gt;

&lt;p&gt;Return the number of good splits you can make in s.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/sliding-window/&quot;&gt;Sliding Window Technique&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;int numSplits(string s) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; chars(s.size()-1, vector&amp;lt;int&amp;gt; (2,0));
        int count = 0;
        unordered_set&amp;lt;char&amp;gt; s1;
        unordered_set&amp;lt;char&amp;gt; s2;
        size_t i = 0, j = chars.size() -1;
        while(i &amp;lt; chars.size() &amp;amp;&amp;amp; j &amp;gt;= 0){
            s1.insert(s[i]);
            s2.insert(s[j+1]);
            chars[i][0] = (int)s1.size();
            chars[j][1] = (int)s2.size();
            ++i;
            --j;
        }
        for(auto i : chars){
            if(i[0] == i[1]){
                ++count;
            }
        }
        return count;
    }
};&lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time copmlexity: &lt;i&gt;O(b)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="blog" /><category term="algorithm" /><category term="leetcode" /><category term="weekly_contest" /><category term="DFS" /><summary type="html">LINK</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Leetcode Weekly Contest 197 - Count Nodes with the same number in subtrees</title><link href="https://parkyo.github.io/categories/leetcode-countSubTree/" rel="alternate" type="text/html" title="Leetcode Weekly Contest 197 - Count Nodes with the same number in subtrees" /><published>2020-07-25T00:00:00+09:00</published><updated>2020-07-25T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/leetcode-countSubTree</id><content type="html" xml:base="https://parkyo.github.io/categories/leetcode-countSubTree/">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/&quot;&gt;LINK&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;level--medium&quot;&gt;Level : Medium&lt;/h3&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).&lt;/p&gt;

&lt;p&gt;The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.&lt;/p&gt;

&lt;p&gt;Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.&lt;/p&gt;

&lt;p&gt;A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;DFS search on tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;class Solution {
public:
    struct Node{
        int val;
        vector&amp;lt;Node*&amp;gt; children;
        Node(int in_val): val(in_val){
        }
    };
    
    void dfs(size_t root, size_t i, vector&amp;lt;Node*&amp;gt;&amp;amp; tree, string&amp;amp; labels, vector&amp;lt;int&amp;gt;&amp;amp; ans){
        if(i &amp;lt; tree.size()){
            for (auto n : tree[i]-&amp;gt;children){
                if(labels[n-&amp;gt;val] == labels[root]){
                    ++ans[root];
                }
                dfs(root, n-&amp;gt;val, tree, labels, ans);
                
            }

        }

    }

    vector&amp;lt;int&amp;amp;gt countSubTrees(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges, string labels) {
        vector&amp;lt;int&amp;gt; ans(n,1);
        vector&amp;lt;Node*&amp;gt; tree(n);
        for(size_t i = 0; i &amp;lt; n; ++i){
            Node* n = new Node((int)i);
            tree[i] = n;
        }
        for(auto e : edges){
            tree[e[0]]-&amp;gt;children.push_back(tree[e[1]]);
        }
        for(size_t i = 0; i &amp;lt; n; ++i){
            dfs(i, i,tree, labels, ans);
        }

        return ans;
    }
};&lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time copmlexity: &lt;i&gt;O(n*E)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="blog" /><category term="algorithm" /><category term="leetcode" /><category term="weekly_contest" /><category term="DFS" /><summary type="html">LINK</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Leetcode Weekly Contest 197 - Path with Maximum Probability</title><link href="https://parkyo.github.io/categories/leetcode-path-max-prob/" rel="alternate" type="text/html" title="Leetcode Weekly Contest 197 - Path with Maximum Probability" /><published>2020-07-22T00:00:00+09:00</published><updated>2020-07-22T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/leetcode-path-max-prob</id><content type="html" xml:base="https://parkyo.github.io/categories/leetcode-path-max-prob/">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-substrings-with-only-1s/&quot;&gt;LINK&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;level--medium&quot;&gt;Level : Medium&lt;/h3&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].&lt;/p&gt;

&lt;p&gt;Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.&lt;/p&gt;

&lt;p&gt;If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;BFS search&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

class Solution {

    
public:
    
    double maxProbability(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges, vector&amp;lt;double&amp;gt;&amp;amp; succProb, int start, int end) {
        vector&amp;lt;unordered_map&amp;lt;int, double&amp;gt;&amp;gt; graph(n);
        for(size_t i = 0; i &amp;lt; edges.size(); ++i){
            graph[edges[i][0]][edges[i][1]] =  succProb[i];
            graph[edges[i][1]][edges[i][0]] = succProb[i];
        }
        
        vector&amp;lt;double&amp;gt; ps(n, 0);
        ps[start] = 1.0;
        queue&amp;lt;int&amp;gt; q;
        q.push(start);
        while(!q.empty()){
            int cur = q.front();
            q.pop();
            for (auto it = graph[cur].begin(); it != graph[cur].end(); ++it){
                double pos = (it-&amp;gt;second) * ps[cur];
                if(pos &amp;gt; ps[it-&amp;gt;first]){
                    ps[it-&amp;gt;first] = pos;
                    q.push(it-&amp;gt;first);
                }
            }

        }
        return ps[end];
        
    }
};&lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time copmlexity: &lt;i&gt;O(V*E)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="blog" /><category term="algorithm" /><category term="leetcode" /><category term="weekly_contest" /><category term="dijkastra" /><summary type="html">LINK</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Bellman Ford algorithm</title><link href="https://parkyo.github.io/categories/Bellmanford/" rel="alternate" type="text/html" title="Bellman Ford algorithm" /><published>2020-07-21T00:00:00+09:00</published><updated>2020-07-21T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/Bellmanford</id><content type="html" xml:base="https://parkyo.github.io/categories/Bellmanford/">&lt;p&gt;&lt;strong&gt;Bellman Ford&lt;/strong&gt; works like Dijkstra’s algorithm except that it also allows negative weights. It is simpler and suites better for the distributed system. 
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;alogorithm&quot;&gt;Alogorithm&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;void BellmanFord(struct Graph* graph, int src) 
{ 
    int V = graph-&amp;gt;V; 
    int E = graph-&amp;gt;E; 
    int dist[V]; 
    &lt;/strong&gt;
    &lt;i&gt;// Step 1: Initialize distances from src to all other vertices 
    // as INFINITE &lt;/i&gt;&lt;strong&gt;
    for (int i = 0; i &amp;lt; V; i++) 
        dist[i] = INT_MAX; 
    dist[src] = 0; 
    &lt;/strong&gt;
    &lt;i&gt;// Step 2: Relax all edges |V| - 1 times. A simple shortest 
    // path from src to any other vertex can have at-most |V| - 1 
    // edges &lt;/i&gt;&lt;strong&gt;
    for (int i = 1; i &amp;lt;= V - 1; i++) { 
        for (int j = 0; j &amp;lt; E; j++) { 
            int u = graph-&amp;gt;edge[j].src; 
            int v = graph-&amp;gt;edge[j].dest; 
            int weight = graph-&amp;gt;edge[j].weight; 
            if (dist[u] != INT_MAX &amp;amp;&amp;amp; dist[u] + weight &amp;lt; dist[v]) 
                dist[v] = dist[u] + weight; 
        } 
    } 
  &lt;/strong&gt;
    &lt;i&gt;// Step 3: check for negative-weight cycles.  The above step 
    // guarantees shortest distances if graph doesn't contain 
    // negative weight cycle.  If we get a shorter path, then there 
    // is a negative weight cycle. &lt;/i&gt;&lt;strong&gt;
    for (int i = 0; i &amp;lt; E; i++) { 
        int u = graph-&amp;gt;edge[i].src; 
        int v = graph-&amp;gt;edge[i].dest; 
        int weight = graph-&amp;gt;edge[i].weight; 
        if (dist[u] != INT_MAX &amp;amp;&amp;amp; dist[u] + weight &amp;lt; dist[v]) { 
            printf(&quot;Graph contains negative weight cycle&quot;); 
            return; // If negative cycle is detected, simply return 
        } 
    } 
  
    printArr(dist, V); 
  
    return; 
} &lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;O(VE)&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/&quot;&gt;GeeksForGeeks&lt;/a&gt;&lt;/p&gt;</content><category term="blog" /><category term="algorithm" /><category term="leetcode" /><category term="greedy" /><summary type="html">Bellman Ford works like Dijkstra’s algorithm except that it also allows negative weights. It is simpler and suites better for the distributed system.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry><entry><title type="html">Leetcode Weekly Contest 197 - The Number of Substrings with 1’s</title><link href="https://parkyo.github.io/categories/leetcode-num-substrings-with-1s/" rel="alternate" type="text/html" title="Leetcode Weekly Contest 197 - The Number of Substrings with 1's" /><published>2020-07-19T00:00:00+09:00</published><updated>2020-07-19T00:00:00+09:00</updated><id>https://parkyo.github.io/categories/leetcode-num-substrings-with-1s</id><content type="html" xml:base="https://parkyo.github.io/categories/leetcode-num-substrings-with-1s/">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-substrings-with-only-1s/&quot;&gt;LINK&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;level--medium&quot;&gt;Level : Medium&lt;/h3&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a binary string s (a string consisting only of ‘0’ and ‘1’s).&lt;/p&gt;

&lt;p&gt;Return the number of substrings with all characters 1’s.&lt;/p&gt;

&lt;p&gt;Since the answer may be too large, return it modulo 10^9 + 7..&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&lt;strong&gt;class Solution {
public:
    unsigned long long count(unsigned long long n){
        unsigned long long ans = (n + 1)*(n/2);
        if(n%2 != 0){
            ans += n/2 + 1;
        }
        return ans;
    }
    
    int numSub(string s) {
        unsigned long long ans = 0;
        int num = 0;
        for (auto c : s){
            if (c == '1'){
                ++num;
            }else{
                ans += count(num);
                num = 0;
            }
        }
        ans += count(num);
        return ans % (unsigned long long)(pow(10,9) + 7);
    }
};&lt;/strong&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time copmlexity: &lt;i&gt;O(n)&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="blog" /><category term="algorithm" /><category term="leetcode" /><category term="weekly_contest" /><summary type="html">LINK</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://parkyo.github.io" /></entry></feed>
